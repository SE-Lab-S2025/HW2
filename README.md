# SE_Lab_HW2

## اهداف

در این آزمایش دانشجویان با اصول شی‌گرایی با تاکید بر اصول SOLID آشنا می‌شوند:

- اصول برقراری اصول SOLID
- عواقب نقض اصول SOLID
- ارائه راهکار برای برقراری اصول شی‌گرایی و اعمال آن راهکار بر روی کد
- درک عمیق مزایای به کارگیری اصول شی‌گرایی

## شرح مراحل
طبق دستورالعمل آزمایش دوم مراحل به صورت زیر انجام می‌شوند.

### مرحله‌ی اول
برای اضافه کردن کلاس جدید TelegramMessageService مجبور به تغییر سایر کلاس‌ها می‌شویم که در بخش بعد توضیحات آن‌ها گفته می‌شود.
پروژه بعد از اعمال تغییرات در پوشه‌ی Step-01-without-solid ذخیره شده.

### مرحله‌ی دوم

جدول زیر خلاصه‌ای از تغییرات اعمال شده در مرحله‌ی اول را نمایش می‌دهد:


| ردیف | محل اعمال تغییرات          | عنوان تغییر                              | شرح تغییر                                                                 |
|------|----------------------------|------------------------------------------|---------------------------------------------------------------------------|
| 1    | TelegramMessageService     | افزودن کلاس سرویس ارسال پیام تلگرامی    | کلاس جدید شامل دو متد جدید `sendTelegramMessage` و `validateTelegramID` و همچنین دو متد با بدنه خالی که باید از کلاس پدر به ارث برده شوند. |
| 2    | TelegramMessage            | افزودن کلاس مدل پیام تلگرامی            | کلاس مدل جدید شامل دو رشته آیدی مقصد و مبدا و توابع getter/setter مرتبط. |
| 3    | MessageService             | افزودن تابع ارسال پیام تلگرامی          | افزودن یک تابع `void` با عنوان `sendTelegramMessage`|
| 4    | EmailMessageService        | اورراید تابع ارسال پیام تلگرامی         | افزودن یک تابع `void` با بدنه‌ی خالی و عنوان `sendTelegramMessage`|
| 5    | SmsMessageService          | اورراید تابع ارسال پیام تلگرامی         | افزودن یک تابع `void` با بدنه‌ی خالی و عنوان `sendTelegramMessage`|
| 6    | Main                       | اضافه کردن گزینه سوم برای انتخاب کاربر   | اضافه کردن حالت سوم به سوئیچ کیس و پیاده‌سازی ارسال پیام تلگرامی.       |

### مرحله سوم
 جدول بررسی موارد تحقق و نقض اصول SOLID به جز اصل اول صرفا با توجه به کلاس‌های  بسته‌ی Services و کلاس Main:
<table dir='rtl'>
<tbody>
<tr>
<td rowspan="2">
<p>اصل 2</p>
<p>Open-Close Principle (OCP)</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>کلاس‌های <code>EmailMessageService</code> و <code>SmsMessageService</code> از واسط <code>MessageService</code> ارث‌بری می‌کنند و می‌توانند بدون تغییر سایر بخش‌ها تغییر کنند.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>هر بار که بخواهیم روش جدیدی برای ارسال پیام اضافه کنیم، باید واسط <code>MessageService</code> و کلاس‌‌هایی که از آن ارث‌بری می‌کنند را تغییر دهیم. </p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 3</p>
<p>Liskov Substitution Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>همه کلاس‌هایی که از <code>MessageService</code> ارث‌بری کرده‌اند می‌توانند جایگزین یکدیگر شوند بدون این که عملکرد اصلی تغییر کند.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>در هر کلاس فرزند، برخی از متدها بلا استفاده مانده‌اند و بدنه‌ای خالی دارند، که می‌تواند منجر به رفتارهای غیرمنتظره شود.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 4</p>
<p>Interface Segregation Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>هیچ موردی تحقق نیافته است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>واسط  <code>MessageService</code> شامل متدهایی است که در هر پیاده‌سازی نیازی به همه آنها نیست و بدنه‌ای خالی دارند، این امر باعث نقض این اصل می‌شود.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 5</p>
<p>Dependency Inversion Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>کلاس <code>Main</code> به جای وابستگی به کلاس‌های خاص، به واسط <code>MessageService</code> وابسته است که این اصل را تحقق می‌بخشد.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>هیچ موردی نقض نشده است.</p>
</td>
</tr>
</tbody>
</table>

### مرحله چهارم
| اصل مربوطه (از اصول SOLID) | علت نقض | راه حل پیشنهادی |
|------------------------------|----------|-----------------|
| **Open-Close Principle (OCP)** | هر بار که نیاز به اضافه کردن روش جدید ارسال پیام باشد، باید واسط `MessageService` و کلاس‌های وابسته تغییر کنند. | تعریف یک واسط عمومی به نام `MessageService` که فقط یک متد `sendMessage(Message message)` داشته باشد و سپس برای هر نوع پیام (`SmsMessage`, `EmailMessage`, `TelegramMessage`) یک کلاس جداگانه که این واسط را پیاده‌سازی کند، ایجاد شود. این کار نیاز به تغییر واسط و کلاس‌های قبلی هنگام افزودن پیام جدید را برطرف می‌کند. |
| **Liskov Substitution Principle (LSP)** | کلاس‌های پیاده‌سازی کننده واسط `MessageService` متدهایی با بدنه خالی دارند که عملاً قابل استفاده نیستند و رفتاری غیرمنتظره دارند. | شکستن واسط عمومی به واسط‌های تخصصی‌تر مانند `SmsMessageService`, `EmailMessageService`, `TelegramMessageService` که فقط متدهای مربوطه را داشته باشند و حذف متدهای بی‌مورد از پیاده‌سازی‌های هر کلاس. این تغییر مانع ایجاد متدهای بی‌استفاده با بدنه‌های خالی خواهد شد. |
| **Interface Segregation Principle (ISP)** | واسط `MessageService` متدهایی دارد که در کلاس‌های خاص به آن‌ها نیازی نیست و منجر به ایجاد متدهای خالی شده است. | ایجاد واسط‌های کوچک‌تر و تخصصی‌تر (همانند راه حل قبلی برای LSP)، هر واسط فقط شامل متدهای مورد نیاز هر سرویس باشد. به این صورت، کلاس‌ها مجبور به پیاده‌سازی متدهای غیرضروری نخواهند بود. |
| **Dependency Inversion Principle (DIP)** | کلاس `Main` مستقیماً به کلاس خاص `MessageService` وابسته است که باعث نقض اصل DIP شده است. | استفاده از تزریق وابستگی (Dependency Injection) و معرفی یک Factory یا Dependency Injection Container برای ایجاد وابستگی‌ها به‌صورت پویا. به این صورت، کلاس‌های سطح بالا به انتزاع‌ها وابسته خواهند بود نه به کلاس‌های مشخص. |


<div dir="rtl">

## سؤالات پایانی

پاسخ سؤالات زیر را در پایان گزارش به صورت جداگانه بنویسید.

1. اگر اصول شی‌گرایی از ابتدا برقرار بود و شما سرویس جدید را به پروژه اضافه می‌کردید، چند مورد از تغییرات ثبت‌شده در جدول مرحله دوم حذف می‌شد؟ و در نهایت با چند تغییر در سطح کد، این سرویس اضافه می‌شد؟ (عدد آن را حتماً اعلام کنید.)
   در صورت رعایت اصول SOLID، تمامی موارد تغییر در واسط‌ها و متدهای اضافی حذف می‌شدند. در این حالت، تنها کافی بود یک کلاس جدید برای سرویس موردنظر اضافه شود. بنابراین، تعداد تغییرات حذف‌شده برابر ۵ مورد خواهد بود و فقط ۱ تغییر (اضافه کردن کلاس جدید) لازم بود.
2. با توجه به آنچه که انجام دادید، در دو خط توضیح دهید که رعایت اصول شی‌گرایی، چه مزایایی را برای پروژه شما فراهم می‌کند؟
   رعایت اصول SOLID باعث می‌شود کد پروژه قابل گسترش، نگهداری و تست آسان‌تر باشد. همچنین وابستگی‌ها را کاهش داده و انعطاف‌پذیری و کیفیت طراحی را افزایش می‌دهد.
</div>